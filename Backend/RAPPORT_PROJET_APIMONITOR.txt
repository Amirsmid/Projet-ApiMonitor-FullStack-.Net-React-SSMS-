# ðŸ“Š RAPPORT TECHNIQUE - ApiMonitor
## Plateforme de Monitoring API en Temps RÃ©el

---

## ðŸ“‹ TABLE DES MATIÃˆRES

1. [Vue d'ensemble du projet](#1-vue-densemble-du-projet)
2. [Architecture technique](#2-architecture-technique)
3. [Composants Backend](#3-composants-backend)
4. [Composants Frontend](#4-composants-frontend)
5. [Flux de donnÃ©es et communication](#5-flux-de-donnÃ©es-et-communication)
6. [SystÃ¨me d'authentification](#6-systÃ¨me-dauthentification)
7. [Analytics et monitoring](#7-analytics-et-monitoring)
8. [Guide d'utilisation](#8-guide-dutilisation)
9. [DÃ©ploiement et configuration](#9-dÃ©ploiement-et-configuration)

---

## 1. VUE D'ENSEMBLE DU PROJET

### ðŸŽ¯ Objectif
ApiMonitor est une plateforme complÃ¨te de monitoring d'APIs REST qui permet de :
- **Surveiller** les appels API en temps rÃ©el
- **Analyser** les performances et les tendances
- **DÃ©tecter** les anomalies et les erreurs
- **GÃ©rer** les utilisateurs avec des rÃ´les diffÃ©renciÃ©s
- **Exporter** les donnÃ©es pour analyse externe

### ðŸ—ï¸ Architecture gÃ©nÃ©rale
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Frontend      â”‚    â”‚   Backend       â”‚    â”‚   Base de       â”‚
â”‚   React + TS    â”‚â—„â”€â”€â–ºâ”‚   ASP.NET Core  â”‚â—„â”€â”€â–ºâ”‚   DonnÃ©es       â”‚
â”‚   Bootstrap     â”‚    â”‚   SignalR       â”‚    â”‚   SQL Server    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. ARCHITECTURE TECHNIQUE

### ðŸ”§ Stack technologique

#### Backend (ASP.NET Core 8)
- **Framework** : ASP.NET Core 8.0
- **Base de donnÃ©es** : SQL Server avec Entity Framework Core
- **Authentification** : JWT (JSON Web Tokens)
- **Communication temps rÃ©el** : SignalR
- **Documentation API** : Swagger/OpenAPI
- **SÃ©curitÃ©** : BCrypt pour le hachage des mots de passe

#### Frontend (React 18)
- **Framework** : React 18 avec TypeScript
- **UI Framework** : Bootstrap 5
- **Graphiques** : Chart.js
- **Communication temps rÃ©el** : SignalR Client
- **Routing** : React Router
- **HTTP Client** : Axios

### ðŸ“ Structure des dossiers
```
ApiMonitor/
â”œâ”€â”€ Controllers/          # Endpoints API REST
â”œâ”€â”€ Models/              # EntitÃ©s de donnÃ©es
â”œâ”€â”€ DTOs/                # Objets de transfert
â”œâ”€â”€ Data/                # Contexte Entity Framework
â”œâ”€â”€ Hubs/                # SignalR Hubs
â”œâ”€â”€ Middleware/          # Middleware personnalisÃ©s
â”œâ”€â”€ Services/            # Services mÃ©tier
â””â”€â”€ Migrations/          # Migrations de base de donnÃ©es

apimonitor-frontend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/      # Composants React
â”‚   â”œâ”€â”€ services/        # Services API
â”‚   â”œâ”€â”€ types/           # Types TypeScript
â”‚   â””â”€â”€ App.css          # Styles globaux
```

---

## 3. COMPOSANTS BACKEND

### ðŸŽ® Controllers (Endpoints API)

#### AuthController
**RÃ´le** : Gestion de l'authentification et des utilisateurs
```csharp
[HttpPost("login")]     // Connexion utilisateur
[HttpPost("register")]  // CrÃ©ation d'utilisateur (Admin uniquement)
[HttpGet("check-admin-exists")] // VÃ©rification existence admin
```

**Fonctionnement** :
1. **Login** : VÃ©rifie email/mot de passe â†’ gÃ©nÃ¨re JWT
2. **Register** : CrÃ©e nouvel utilisateur avec rÃ´le (Admin/Viewer)
3. **SÃ©curitÃ©** : Mots de passe hachÃ©s avec BCrypt

#### AnalyticsController
**RÃ´le** : Fournit les donnÃ©es d'analyse et de statistiques
```csharp
[HttpGet("overview")]        // Vue d'ensemble (totaux, moyennes)
[HttpGet("timeseries")]      // DonnÃ©es temporelles (graphiques)
[HttpGet("topendpoints")]    // Endpoints les plus utilisÃ©s
[HttpGet("tokens")]          // Statistiques des tokens
```

**Fonctionnement** :
1. **Overview** : Calcule totaux, moyennes, pourcentages d'erreur
2. **TimeSeries** : Groupe les logs par intervalles (heure/jour)
3. **TopEndpoints** : Trie les endpoints par frÃ©quence d'usage
4. **Tokens** : Analyse l'utilisation des tokens d'authentification

#### LogsController
**RÃ´le** : Gestion des logs d'API
```csharp
[HttpGet]              // RÃ©cupÃ©ration des logs avec filtres
[HttpGet("export/csv")] // Export CSV des logs
[HttpPost("ingest")]   // Ingestion de nouveaux logs
[HttpDelete("purge")]  // Suppression des anciens logs
```

**Fonctionnement** :
1. **GET** : Pagination, filtres par mÃ©thode, statut, date, chemin
2. **Export** : GÃ©nÃ©ration de fichiers CSV pour analyse externe
3. **Ingest** : Ajout de logs via API (pour intÃ©gration externe)
4. **Purge** : Nettoyage des logs anciens (gestion de l'espace)

#### TokensController
**RÃ´le** : Analyse des tokens d'authentification
```csharp
[HttpGet("summary")]      // RÃ©sumÃ© des tokens
[HttpGet("suspicious")]   // Tokens suspects (anomalies)
[HttpGet("expired")]      // Tokens expirÃ©s/inactifs
```

### ðŸ“Š Models (EntitÃ©s de donnÃ©es)

#### User
```csharp
public class User
{
    public int Id { get; set; }
    public string Email { get; set; }           // Email unique
    public string DisplayName { get; set; }     // Nom d'affichage
    public string PasswordHash { get; set; }    // Mot de passe hachÃ©
    public string Role { get; set; }            // Admin ou Viewer
    public DateTime CreatedUtc { get; set; }    // Date de crÃ©ation
}
```

#### ApiLog
```csharp
public class ApiLog
{
    public int Id { get; set; }
    public DateTime TimestampUtc { get; set; }  // Horodatage
    public string Method { get; set; }          // GET, POST, PUT, DELETE
    public string Path { get; set; }            // Chemin de l'endpoint
    public string? QueryString { get; set; }    // ParamÃ¨tres de requÃªte
    public int StatusCode { get; set; }         // Code de rÃ©ponse HTTP
    public long? DurationMs { get; set; }       // DurÃ©e de traitement
    public string? ClientIp { get; set; }       // Adresse IP client
    public string? UserAgent { get; set; }      // User-Agent du navigateur
    public string? TokenHash { get; set; }      // Hash du token (anonymisÃ©)
}
```

### ðŸ”„ DTOs (Data Transfer Objects)

#### Pourquoi utiliser des DTOs ?

**1. SÃ©curitÃ©** : Les DTOs Ã©vitent l'exposition de donnÃ©es sensibles
```csharp
// âŒ Mauvais : exposer directement le modÃ¨le User
public User GetUser(int id) { return _db.Users.Find(id); }

// âœ… Bon : utiliser un DTO qui masque le PasswordHash
public UserDto GetUser(int id) { 
    return _db.Users.Where(u => u.Id == id)
                   .Select(u => new UserDto { Email = u.Email, Role = u.Role })
                   .FirstOrDefault(); 
}
```

**2. Validation** : ContrÃ´le des donnÃ©es d'entrÃ©e
```csharp
public record RegisterRequest(
    [param: Required, EmailAddress] string Email,
    [param: Required, MinLength(3)] string DisplayName,
    [param: Required, MinLength(6)] string Password,
    [param: Required] string Role
);
```

**3. Versioning** : Ã‰volution de l'API sans casser les clients
```csharp
// Version 1
public record UserResponse(string Email, string Role);

// Version 2 (ajout de DisplayName sans casser l'existant)
public record UserResponse(string Email, string Role, string DisplayName);
```

**4. Performance** : Transfert uniquement des donnÃ©es nÃ©cessaires
```csharp
// Au lieu de transfÃ©rer tout l'objet ApiLog (potentiellement lourd)
public record LogSummaryDto(
    DateTime Timestamp,
    string Method,
    string Path,
    int StatusCode,
    long DurationMs
);
```

#### DTOs principaux du projet

**AuthDtos.cs** :
- `LoginRequest` : Email + mot de passe
- `RegisterRequest` : Email + mot de passe + nom + rÃ´le
- `AuthResponse` : Token JWT + informations utilisateur

**AnalyticsDtos.cs** :
- `OverviewDataDto` : Totaux, moyennes, pourcentages
- `TimeSeriesPointDto` : Point de donnÃ©es temporelles
- `EndpointStatsDto` : Statistiques par endpoint
- `TokenStatsDto` : Statistiques par token

### ðŸ—„ï¸ Data (Entity Framework)

#### AppDbContext
```csharp
public class AppDbContext : DbContext
{
    public DbSet<User> Users { get; set; }
    public DbSet<ApiLog> ApiLogs { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Configuration des relations et contraintes
        modelBuilder.Entity<User>()
            .HasIndex(u => u.Email)
            .IsUnique();
            
        modelBuilder.Entity<ApiLog>()
            .HasIndex(l => l.TimestampUtc);
    }
}
```

**FonctionnalitÃ©s** :
- **Migrations** : Ã‰volution automatique du schÃ©ma de base
- **Indexation** : Optimisation des requÃªtes frÃ©quentes
- **Relations** : Gestion des liens entre entitÃ©s
- **Validation** : Contraintes au niveau base de donnÃ©es

### ðŸ”Œ Hubs (SignalR)

#### LogsHub
```csharp
public class LogsHub : Hub
{
    public async Task JoinGroup(string groupName)
    {
        await Groups.AddToGroupAsync(Context.ConnectionId, groupName);
    }
    
    public async Task SendLogUpdate(ApiLog log)
    {
        await Clients.All.SendAsync("LogReceived", log);
    }
}
```

**Pourquoi SignalR ?**

**1. Communication temps rÃ©el** :
- Mise Ã  jour automatique du dashboard
- Notifications instantanÃ©es d'erreurs
- Synchronisation multi-utilisateurs

**2. Performance** :
- WebSockets pour connexions persistantes
- Fallback automatique (Server-Sent Events, Long Polling)
- Optimisation de la bande passante

**3. SimplicitÃ© d'utilisation** :
```javascript
// CÃ´tÃ© client
connection.on("LogReceived", (log) => {
    updateDashboard(log);
});
```

**4. Groupes et ciblage** :
```csharp
// Envoyer Ã  tous les admins
await Clients.Group("Admins").SendAsync("Alert", alert);

// Envoyer Ã  un utilisateur spÃ©cifique
await Clients.User(userId).SendAsync("Notification", message);
```

### ðŸ›¡ï¸ Middleware

#### RequestLoggingMiddleware
```csharp
public async Task Invoke(HttpContext context, AppDbContext db)
{
    var sw = Stopwatch.StartNew();
    
    // Extraction du token (anonymisÃ©)
    string? tokenHash = ExtractTokenHash(context);
    
    try
    {
        await _next(context);
    }
    finally
    {
        // Enregistrement du log
        var log = new ApiLog
        {
            TimestampUtc = DateTime.UtcNow,
            Method = context.Request.Method,
            Path = context.Request.Path,
            StatusCode = context.Response.StatusCode,
            DurationMs = sw.ElapsedMilliseconds,
            TokenHash = tokenHash
        };
        
        db.ApiLogs.Add(log);
        await db.SaveChangesAsync();
    }
}
```

**FonctionnalitÃ©s** :
- **Logging automatique** : Tous les appels API sont enregistrÃ©s
- **Anonymisation** : Hash des tokens pour la sÃ©curitÃ©
- **Performance** : Mesure du temps de traitement
- **MÃ©tadonnÃ©es** : IP, User-Agent, paramÃ¨tres de requÃªte

---

## 4. COMPOSANTS FRONTEND

### ðŸŽ¨ Architecture React

#### Structure des composants
```
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Auth/
â”‚   â”‚   â””â”€â”€ Login.tsx           # Formulaire de connexion/inscription
â”‚   â”œâ”€â”€ Dashboard/
â”‚   â”‚   â”œâ”€â”€ Dashboard.tsx       # Page principale
â”‚   â”‚   â”œâ”€â”€ OverviewCards.tsx   # Cartes de statistiques
â”‚   â”‚   â”œâ”€â”€ Charts.tsx          # Graphiques Chart.js
â”‚   â”‚   â”œâ”€â”€ LogsPage.tsx        # Page des logs
â”‚   â”‚   â”œâ”€â”€ AnalyticsPage.tsx   # Page d'analytics
â”‚   â”‚   â”œâ”€â”€ LogsTable.tsx       # Tableau des logs
â”‚   â”‚   â””â”€â”€ Filters.tsx         # Filtres de recherche
â”‚   â””â”€â”€ Layout/
â”‚       â””â”€â”€ Navbar.tsx          # Barre de navigation
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ api.ts                  # Service API REST
â”‚   â””â”€â”€ signalR.ts              # Service SignalR
â””â”€â”€ types/
    â””â”€â”€ index.ts                # Types TypeScript
```

### ðŸ”§ Services

#### api.ts (Service API REST)
```typescript
class ApiService {
  private api: AxiosInstance;
  
  constructor() {
    this.api = axios.create({
      baseURL: 'https://localhost:5001',
      headers: { 'Content-Type': 'application/json' }
    });
    
    // Intercepteur pour ajouter le token JWT
    this.api.interceptors.request.use((config) => {
      const token = localStorage.getItem('authToken');
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });
    
    // Intercepteur pour gÃ©rer les erreurs 401
    this.api.interceptors.response.use(
      (response) => response,
      (error) => {
        if (error.response?.status === 401) {
          localStorage.removeItem('authToken');
          window.location.href = '/login';
        }
        return Promise.reject(error);
      }
    );
  }
}
```

**FonctionnalitÃ©s** :
- **Authentification automatique** : Ajout du token JWT Ã  chaque requÃªte
- **Gestion d'erreurs** : Redirection automatique en cas d'expiration
- **Configuration centralisÃ©e** : URL de base, headers par dÃ©faut
- **Types TypeScript** : SÃ©curitÃ© de type pour les rÃ©ponses API

#### signalR.ts (Service SignalR)
```typescript
class SignalRService {
  private connection: signalR.HubConnection;
  
  constructor() {
    this.connection = new signalR.HubConnectionBuilder()
      .withUrl('https://localhost:5001/hubs/logs')
      .withAutomaticReconnect()
      .build();
  }
  
  async startConnection(): Promise<void> {
    await this.connection.start();
  }
  
  setOnLogReceived(callback: (log: ApiLog) => void): void {
    this.connection.on('LogReceived', callback);
  }
  
  setOnOverviewUpdate(callback: (data: OverviewData) => void): void {
    this.connection.on('OverviewUpdated', callback);
  }
}
```

**FonctionnalitÃ©s** :
- **Reconnexion automatique** : Gestion des dÃ©connexions rÃ©seau
- **Callbacks typÃ©s** : SÃ©curitÃ© TypeScript pour les Ã©vÃ©nements
- **Gestion d'Ã©tat** : Suivi de l'Ã©tat de connexion
- **Performance** : Connexion WebSocket persistante

### ðŸŽ¯ Composants principaux

#### Dashboard.tsx
```typescript
const Dashboard: React.FC = () => {
  const [overviewData, setOverviewData] = useState<OverviewData | null>(null);
  const [connectionStatus, setConnectionStatus] = useState<string>('Disconnected');
  
  useEffect(() => {
    loadDashboard();
    setupSignalR();
    
    // Actualisation automatique toutes les 30 secondes
    const interval = setInterval(loadDashboard, 30000);
    
    return () => {
      clearInterval(interval);
      signalRService.stopConnection();
    };
  }, []);
  
  const setupSignalR = async () => {
    signalRService.setOnOverviewUpdate((data) => {
      setOverviewData(data);
    });
    
    signalRService.setOnLogReceived((log) => {
      setLogs(prevLogs => [log, ...prevLogs.slice(0, 49)]);
    });
    
    await signalRService.startConnection();
    setConnectionStatus('Connected');
  };
};
```

**FonctionnalitÃ©s** :
- **DonnÃ©es en temps rÃ©el** : Mise Ã  jour automatique via SignalR
- **Actualisation pÃ©riodique** : Fallback toutes les 30 secondes
- **Gestion d'erreurs** : Affichage des erreurs de connexion
- **Performance** : Limitation du nombre de logs affichÃ©s

#### LogsPage.tsx
```typescript
const LogsPage: React.FC = () => {
  const [logs, setLogs] = useState<ApiLog[]>([]);
  const [filters, setFilters] = useState<FilterOptions>({});
  const [loading, setLoading] = useState(false);
  
  const handleFiltersChange = async (newFilters: FilterOptions) => {
    setLoading(true);
    try {
      const filteredLogs = await apiService.getLogs(newFilters, 1, 50);
      setLogs(filteredLogs);
    } catch (error) {
      console.error('Filter error:', error);
    } finally {
      setLoading(false);
    }
  };
  
  const handleExport = async () => {
    const blob = await apiService.exportCsv(filters);
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `apilogs_${new Date().toISOString().slice(0, 10)}.csv`;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
  };
};
```

**FonctionnalitÃ©s** :
- **Filtrage avancÃ©** : Par mÃ©thode, statut, date, chemin
- **Pagination** : Chargement par lots pour les performances
- **Export CSV** : TÃ©lÃ©chargement des donnÃ©es filtrÃ©es
- **Interface responsive** : Adaptation mobile/desktop

---

## 5. FLUX DE DONNÃ‰ES ET COMMUNICATION

### ðŸ”„ Flux d'authentification
```
1. Utilisateur saisit email/mot de passe
2. Frontend â†’ POST /api/auth/login
3. Backend vÃ©rifie credentials â†’ gÃ©nÃ¨re JWT
4. Frontend stocke token dans localStorage
5. Token ajoutÃ© automatiquement aux requÃªtes suivantes
6. Backend valide token sur chaque requÃªte protÃ©gÃ©e
```

### ðŸ“Š Flux de monitoring
```
1. RequÃªte API â†’ RequestLoggingMiddleware
2. Middleware enregistre log en base
3. SignalR Hub notifie les clients connectÃ©s
4. Frontend reÃ§oit notification â†’ met Ã  jour dashboard
5. Analytics calculÃ©es en temps rÃ©el
6. Alertes gÃ©nÃ©rÃ©es si seuils dÃ©passÃ©s
```

### ðŸ” Flux d'analyse
```
1. Utilisateur accÃ¨de Ã  Analytics
2. Frontend â†’ GET /api/analytics/overview
3. Backend calcule statistiques depuis ApiLogs
4. DonnÃ©es retournÃ©es au frontend
5. Graphiques mis Ã  jour avec Chart.js
6. Filtres appliquÃ©s â†’ nouvelles requÃªtes
```

---

## 6. SYSTÃˆME D'AUTHENTIFICATION

### ðŸ” JWT (JSON Web Tokens)

#### Structure du token
```json
{
  "sub": "1",                    // ID utilisateur
  "email": "admin@local.test",   // Email
  "name": "Admin",               // Nom d'affichage
  "role": "Admin",               // RÃ´le (Admin/Viewer)
  "exp": 1757624859,            // Expiration
  "iss": "ApiMonitor",          // Ã‰metteur
  "aud": "ApiMonitorUsers"      // Audience
}
```

#### SÃ©curitÃ©
- **Expiration** : 1 heure par dÃ©faut
- **Signature** : ClÃ© secrÃ¨te cÃ´tÃ© serveur
- **Validation** : VÃ©rification Ã  chaque requÃªte
- **RÃ´les** : ContrÃ´le d'accÃ¨s granulaire

### ðŸ‘¥ SystÃ¨me de rÃ´les

#### Admin
- **AccÃ¨s complet** : Toutes les fonctionnalitÃ©s
- **Gestion utilisateurs** : CrÃ©ation de comptes
- **Administration** : Purge des logs, configuration
- **Analytics avancÃ©es** : Toutes les mÃ©triques

#### Viewer
- **Lecture seule** : Consultation des donnÃ©es
- **Dashboard** : Vue d'ensemble
- **Logs** : Consultation et export
- **Analytics** : Graphiques et statistiques

---

## 7. ANALYTICS ET MONITORING

### ðŸ“ˆ MÃ©triques collectÃ©es

#### Performance
- **DurÃ©e de traitement** : Temps de rÃ©ponse des APIs
- **DÃ©bit** : Nombre de requÃªtes par minute/heure
- **Latence** : Temps moyen de rÃ©ponse
- **Erreurs** : Taux d'erreur par endpoint

#### Utilisation
- **Endpoints populaires** : FrÃ©quence d'utilisation
- **MÃ©thodes HTTP** : RÃ©partition GET/POST/PUT/DELETE
- **Codes de statut** : Distribution 200/400/500
- **Utilisateurs actifs** : Tokens utilisÃ©s

#### SÃ©curitÃ©
- **Tokens suspects** : Utilisation anormale
- **IPs suspectes** : Adresses avec taux d'erreur Ã©levÃ©
- **Tentatives d'intrusion** : RequÃªtes malformÃ©es
- **Sessions expirÃ©es** : Tokens invalides

### ðŸš¨ DÃ©tection d'anomalies

#### Algorithmes utilisÃ©s
```csharp
// DÃ©tection de pics de latence
var avgLatency = logs.Average(l => l.DurationMs);
var threshold = avgLatency * 2; // 200% de la moyenne
var anomalies = logs.Where(l => l.DurationMs > threshold);

// DÃ©tection de taux d'erreur Ã©levÃ©
var errorRate = logs.Count(l => l.StatusCode >= 400) / (double)logs.Count;
if (errorRate > 0.05) // 5% de seuil
{
    alerts.Add($"Taux d'erreur Ã©levÃ©: {errorRate:P}");
}
```

#### Types d'alertes
- **Performance** : Latence > 2x moyenne
- **Erreurs** : Taux d'erreur > 5%
- **Volume** : Pic de trafic > 3x normal
- **SÃ©curitÃ©** : Tentatives d'intrusion dÃ©tectÃ©es

---

## 8. GUIDE D'UTILISATION

### ðŸš€ DÃ©marrage rapide

#### 1. PrÃ©requis
```bash
# Backend
- .NET 8 SDK
- SQL Server (LocalDB ou Express)
- Visual Studio 2022 ou VS Code

# Frontend
- Node.js 18+
- npm ou yarn
```

#### 2. Configuration base de donnÃ©es
```bash
# Dans le dossier ApiMonitor
dotnet ef database update
```

#### 3. DÃ©marrage des services
```bash
# Terminal 1 - Backend
cd ApiMonitor
dotnet run

# Terminal 2 - Frontend
cd apimonitor-frontend
npm start
```

#### 4. AccÃ¨s
- **Frontend** : http://localhost:3000
- **API** : https://localhost:5001
- **Swagger** : https://localhost:5001/swagger

### ðŸ‘¤ Utilisation

#### Connexion
1. Ouvrir http://localhost:3000
2. Utiliser les identifiants par dÃ©faut :
   - Email : `admin@local.test`
   - Mot de passe : `P@ssw0rd!`

#### Navigation
- **Dashboard** : Vue d'ensemble en temps rÃ©el
- **Logs** : Consultation et filtrage des logs
- **Analytics** : Graphiques et statistiques avancÃ©es

#### FonctionnalitÃ©s Admin
- **CrÃ©er un compte** : Bouton dans la navbar
- **GÃ©rer les utilisateurs** : Via l'interface
- **Purger les logs** : Nettoyage de la base

### ðŸ“Š InterprÃ©tation des donnÃ©es

#### Dashboard
- **Total RequÃªtes** : Nombre total d'appels API
- **Erreurs** : Pourcentage de requÃªtes en erreur
- **Latence Moyenne** : Temps de rÃ©ponse moyen
- **DÃ©bit** : RequÃªtes par minute

#### Graphiques
- **Time Series** : Ã‰volution dans le temps
- **Top Endpoints** : Endpoints les plus utilisÃ©s
- **Token Stats** : Utilisation des tokens

---

## 9. DÃ‰PLOIEMENT ET CONFIGURATION

### ðŸ—ï¸ Configuration de production

#### appsettings.json
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=prod-server;Database=ApiMonitor;Trusted_Connection=true;"
  },
  "JwtSettings": {
    "SecretKey": "your-super-secret-key-here",
    "ExpirationHours": 24
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}
```

#### Variables d'environnement
```bash
# Backend
ASPNETCORE_ENVIRONMENT=Production
ASPNETCORE_URLS=https://+:443

# Frontend
REACT_APP_API_URL=https://your-api-domain.com
```

### ðŸ³ Docker (Optionnel)

#### Dockerfile Backend
```dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY ["ApiMonitor.csproj", "."]
RUN dotnet restore
COPY . .
RUN dotnet build -c Release -o /app/build

FROM build AS publish
RUN dotnet publish -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "ApiMonitor.dll"]
```

#### Docker Compose
```yaml
version: '3.8'
services:
  api:
    build: ./ApiMonitor
    ports:
      - "5000:80"
    environment:
      - ConnectionStrings__DefaultConnection=Server=db;Database=ApiMonitor;User=sa;Password=YourPassword123;
    depends_on:
      - db
  
  db:
    image: mcr.microsoft.com/mssql/server:2022-latest
    environment:
      - SA_PASSWORD=YourPassword123
      - ACCEPT_EULA=Y
    ports:
      - "1433:1433"
  
  frontend:
    build: ./apimonitor-frontend
    ports:
      - "3000:80"
    environment:
      - REACT_APP_API_URL=http://api:80
```

### ðŸ“ˆ Monitoring en production

#### MÃ©triques recommandÃ©es
- **CPU/MÃ©moire** : Utilisation des ressources serveur
- **Base de donnÃ©es** : Taille, performance des requÃªtes
- **Logs** : Rotation et archivage
- **SÃ©curitÃ©** : Tentatives d'intrusion, tokens expirÃ©s

#### Alertes
- **DisponibilitÃ©** : API inaccessible
- **Performance** : Latence > seuil configurÃ©
- **Erreurs** : Taux d'erreur > 5%
- **Stockage** : Espace disque < 20%

---

## ðŸŽ¯ CONCLUSION

ApiMonitor est une solution complÃ¨te de monitoring d'APIs qui combine :

### âœ… Points forts
- **Architecture moderne** : ASP.NET Core + React + SignalR
- **Temps rÃ©el** : Mise Ã  jour instantanÃ©e des donnÃ©es
- **SÃ©curitÃ©** : JWT, rÃ´les, anonymisation des donnÃ©es
- **ExtensibilitÃ©** : Architecture modulaire et Ã©volutive
- **Performance** : Optimisations base de donnÃ©es et frontend

### ðŸ”® Ã‰volutions possibles
- **Machine Learning** : DÃ©tection d'anomalies avancÃ©e
- **Multi-tenant** : Support de plusieurs organisations
- **IntÃ©grations** : Slack, Teams, email notifications
- **MÃ©triques custom** : DÃ©finition de mÃ©triques mÃ©tier
- **API Gateway** : IntÃ©gration avec des solutions existantes

### ðŸ“š Technologies maÃ®trisÃ©es
- **Backend** : C#, ASP.NET Core, Entity Framework, SignalR
- **Frontend** : React, TypeScript, Bootstrap, Chart.js
- **Base de donnÃ©es** : SQL Server, migrations, indexation
- **SÃ©curitÃ©** : JWT, BCrypt, validation, autorisation
- **DevOps** : Docker, configuration, dÃ©ploiement

---

*Rapport gÃ©nÃ©rÃ© le : ${new Date().toLocaleDateString('fr-FR')}*
*Version du projet : 1.0.0*
